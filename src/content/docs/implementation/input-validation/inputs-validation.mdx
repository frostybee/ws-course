---
title: Validating Inputs in a REST API
description: Validating Inputs in a REST API
draft: true
sidebar:
    label: "Inputs Validation"
    order: 1
    badge: 
        text: Team Project
        variant: tip
---

## What is Input Validation?

- Input Validation is the process of **verifying** that user or client-provided data meets **expected formats**, types, and **constraints** before processing it.  
- REST APIs handle **requests from clients** (e.g., POST, GET, PUT, DELETE), and unvalidated inputs can lead to **vulnerabilities** like SQL injection, XSS, or simply broken functionality.
- **Validation goal**: Ensures that incoming requests (e.g., JSON payloads, query parameters) **are secure** and **functional**, preventing errors, security vulnerabilities, and unexpected behavior.   
    - **Example:**  
        - Valid: `{"user_id": 123, "name": "Quacker"}`  
        - Invalid: `{"user_id": "abc", "name": "##123@@"}`  

---

## Why Input Validation Matters?

1. **Security**: Prevents **malicious data** from compromising your application, preventing against **injection attacks** (e.g., SQL injection, command injection).
2. **Data integrity**: Ensures inputs **match expected** types, formats, and constraints (e.g., email format, non-negative numbers).
3. **User experience**: Provides clear **error messages** to API consumers when inputs are invalid.
4. **Reliability & stability**: Prevents crashes, runtime errors, or unexpected behavior due to malformed or invalid data.


---

## What to Validate?


### Input Sources
For a REST API, inputs typically come from:
1. **Query Parameters** (e.g., `GET /species?limit=10`)
2. **URL Path Parameters** (e.g., `GET /players/123`)
3. **Request Body** (e.g., JSON in a POST or PUT request)
4. **Request Headers** (e.g., `Accept`, `Authorization`)

---

### Validation Rules

You'll need to validate:
- **Presence**: Is a required field provided?
- **Type**: Is the input an integer, string, boolean, etc.?
- **Format**: Does it match a pattern (e.g., email, date, phone number, etc.)?
- **Range/Length**: Is it within acceptable bounds (e.g., age between 18-100)?
- **Business rules**: Does it make sense in your domain (e.g., order quantity > 0)?

**Examples of validation rules:**
- `name`: Required, string, 2-50 characters.
- `email`: Required, valid email format.
- `age`: Optional, integer, 18-100.

---

## Tools and Approaches in PHP

- **Native PHP functions**:
  - `filter_var()` for sanitizing and validating common types (e.g., email, URL).
  - `isset()`, `empty()` for checking presence.
  - Type casting/checking with `is_int()`, `is_string()`, etc.
- **Third-party libraries**: **[Valitron](https://github.com/vlucas/valitron)**: A simple, stand-alone validation library with no dependencies.

---
## Handling Validation Errors

[Responding to Invalid Input](../../error-handling/error-response).

- HTTP Status: Use `400 Bad Request` for validation failures.  
- Error Format: Return structured JSON with details.  
- Example Response:  
  ```json
  {
    "status": "error",
    "message": "Invalid input",
    "details": [
      {"field": "age", "message": "must be a positive number"},
      {"field": "email", "message": "invalid format"}
    ]
  }
  ```  
- Best Practice: Be specific but avoid leaking internal details.

---

## Example Implementation

- **Inputs validation scenario:** `POST /players` to create a player.  
- **Validation Rules:**  
  - `name`: String, 2-50 chars, required.  
  - `age`: Integer, 18-110, optional.  
- **Code Example (PHP):**
  ```php
  $data = json_decode(file_get_contents('php://input'), true);

  $errors = [];

  // Validate name
  if (!isset($data['name']) || empty($data['name'])) {
      $errors[] = ['field' => 'name', 'message' => 'name is required'];
  } elseif (strlen($data['name']) < 2 || strlen($data['name']) > 50) {
      $errors[] = ['field' => 'name', 'message' => 'name must be between 2 and 50 characters'];
  }

  // Validate age (optional)
  if (isset($data['age']) && (!is_numeric($data['age']) || $data['age'] < 18 || $data['age'] > 110)) {
      $errors[] = ['field' => 'age', 'message' => 'age must be an integer between 18 and 110'];
  }

  if (!empty($errors)) {
      http_response_code(400);
      echo json_encode(['status' => 'error', 'message' => 'Validation failed', 'details' => $errors]);
      exit;
  }
  ```

---

## Input Validation Checklist

1. **Validate early:** Check inputs at the **controller** or **service** layer.
2. **Use schemas:** Define strict data models (e.g., JSON Schema, OpenAPI).
3. **Sanitize inputs:** Remove or escape unsafe characters. Even after validation, use `filter_var()` or similar to sanitize before database insertion.
4. **Enforce types:** Reject mismatched types (e.g., string instead of integer).
5. **Set boundaries:** Limit lengths, ranges, and allowed values.
   - Example: `"age": { "type": "integer", "minimum": 0, "maximum": 150 }`
6. **Use HTTP Status Codes**:
   - 400: Bad Request (malformed JSON).
   - 422: Unprocessable Entity (validation errors).
7. **Centralize Validation**:
   - Move rules and messages to a separate class or helper class for reusability.
8. **Log Errors**:
   - Log validation failures for debugging or security monitoring.
9. **Document Your API**:
   - Use OpenAPI/Swagger to **specify expected inputs** and error responses.
10. **Handle Edge Cases**:
    - Test with empty strings, null values, malformed JSON, and oversized payloads.
