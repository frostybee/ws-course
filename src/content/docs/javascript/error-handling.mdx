---
title: Exception Handling in JavaScript
description: Working with Exceptions in JavaScript
draft: false
sidebar:
  label: 'Exception Handling'
  order: 3
  badge:
    text: Assignment 2
    variant: tip
---

## How to Handle Exceptions in JavaScript?

:::note
In JavaScript, exceptions are typically handled using `try...catch` blocks. This mechanism allows you to **gracefully handle errors** that may occur during the execution of your code, rather than having the script fail completely.
:::

## Basic Syntax of `try...catch`
The general structure of the `try...catch` block is:

```javascript
try {
  // Code that may throw an error
} catch (error) {
  // Code to handle the error
} finally {
  // Optional code that runs regardless of success or failure
}
```
---

## How to Create Custom Exceptions in JavaScript

You can create custom exception classes by extending JavaScript's built-in `Error` class. This allows you to add custom properties like error codes and additional details, making your error handling more informative and structured.

### Creating a Custom Exception Class

The following example shows a `CustomError` class that accepts a `message`, an error `code`, and a `details` object for storing custom data. The class extends `Error` and uses the `super()` method to initialize the parent class while adding custom properties.

```javascript
/**
 * Custom error class that extends the built-in `Error` class.
 * It includes additional properties such as a custom error code and details.
 * This allows for more context when handling errors.
 * 
 * @class
 * @extends {Error}  
 */
class CustomError extends Error {
  /**
   * Creates an instance of CustomError.
   * 
   * @param {string} message - The error message.
   * @param {string|number} code - A custom error code to help identify the type of error.
   * @param {Object} [details] - Optional additional context or details about the error (e.g., a stack trace, data, etc.).
   */
  constructor(message, code, details) {
    super(message); // Call the parent constructor with the message
    this.name = this.constructor.name; // Set the error name to CustomError
    this.code = code; // Custom error code
    this.details = details; // Additional details or context

    // Optional: Ensure the stack trace is correct for this subclass
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}

```

---

### Extending Custom Exceptions

You can create more specific error classes by extending `CustomError`. This is useful for handling different error scenarios:

```javascript
class NotFoundError extends CustomError {
  constructor(message, details) {
    super(message, 404, details);
  }
}

class ValidationError extends CustomError {
  constructor(message, details) {
    super(message, 400, details);
  }
}
```

---

### Using Custom Exceptions

Once you've created a custom exception class, you can throw instances of it with specific data:

```javascript
try {
  // Simulate a situation that triggers an error
  throw new CustomError("Invalid user input", 400, { field: "username", expected: "non-empty" });
} catch (error) {
  if (error instanceof CustomError) {
    console.log("CustomError caught!");    
    console.log(`Message: ${error.message} (Code: ${error.code})`);
    console.log("Details:", error.details);    
  } else {
    console.error("An unknown error occurred:", error);
  }
}
```

The same approach works with specialized error classes like `ValidationError` and `NotFoundError`:

```javascript
try {
  // Simulate validation failure
  throw new ValidationError("Invalid input data", { field: "email", expectedFormat: "email@domain.com" });
} catch (error) {
  if (error instanceof ValidationError) {
    console.log("Caught a ValidationError:");
    console.log(`Message: ${error.message} (Code: ${error.code})`);
    console.log("Details:", error.details);
  } else {
    console.error("Unknown error occurred:", error);
  }
}
```

---

### Handling Multiple Error Types

When dealing with multiple error types, use `instanceof` to handle each one specifically:

```javascript
function simulateError(errorType) {
  switch (errorType) {
    case "validation":
      throw new ValidationError("Validation failed for username", { field: "username", reason: "empty" });
    case "notFound":
      throw new NotFoundError("User not found", { resourceType: "User", id: 123 });
    default:
      throw new CustomError("An unexpected error occurred", 500, { info: "Something went wrong" });
  }
}

try {
  // Test with "validation" error
  simulateError("validation");
} catch (error) {
  if (error instanceof ValidationError) {
    console.log("Handled ValidationError specifically:");
    console.log(`Message: ${error.message} (Code: ${error.code})`);
    console.log("Details:", error.details);
  } else if (error instanceof NotFoundError) {
    console.log("Handled NotFoundError specifically:");
    console.log(`Message: ${error.message} (Code: ${error.code})`);
    console.log("Details:", error.details);
  } else if (error instanceof CustomError) {
    console.log("Handled general CustomError:");
    console.log(`Message: ${error.message} (Code: ${error.code})`);
    console.log("Details:", error.details);
  } else {
    console.error("Unknown error type:", error);
  }
}
```

---

## To Note

:::note[Handling Exceptions]
- **Only catch what you can handle**: Don't catch errors that you cannot properly handle. If you can't recover from an error, it's often better to let it propagate.
- **Provide meaningful error messages**: When throwing or logging errors, make sure the error message helps diagnose the problem.
- **Use specific error types**: If you're throwing errors, consider using custom error classes (e.g., `ValidationError`, `NetworkError`) to make debugging easier.
:::

