---
title: Sorting Collection Resources
description: Sorting Collection Resources
topic: lectures
draft: false
sidebar:
  label: 'Sorting'
  order: 6
---

## What Is Sorting?

Sorting arranges data in a **specific order** (ascending or descending) based on one or more fields. In REST APIs, sorting allows clients to retrieve data in their preferred order using query parameters.

**Common sorting scenarios:**
- Product listings by price (lowest to highest).    
- User lists by registration date (newest first).
- Search results by relevance score.

---

## Why Implement Sorting?

- **Enhanced user experience:** Users can organize data to match their needs.
- **Improved data discovery:** Find relevant information faster (newest posts, cheapest products).
- **Better performance:** Database-level sorting is more efficient than client-side sorting.
- **Reduced data transfer:** Combined with pagination, sorting helps manage large datasets efficiently.

---

## Key Concepts of Sorting

1. **Order**: Sorting can be done in various orders:
   - **Ascending:** From the lowest to the highest value (e.g., A-Z, 0-9).
   - **Descending:** From the highest to the lowest value (e.g., Z-A, 9-0).

2. **Fields**: The data can be sorted based on specific fields or attributes, such as:
   - Strings: (e.g., names).
   - Numbers: (e.g., prices).
   - Dates: (e.g., timestamps).

3. **Multiple sorts:** You can sort by multiple fields, where the first field is the primary sort, and the subsequent fields are used as tiebreakers.

---

## How Sorting is Implemented in RESTful Web Services

### A. Defining Sorting Parameters

In RESTful APIs, sorting is usually implemented through query parameters. Clients can specify sorting preferences in their request. Common query parameters for sorting might include:

- **`sort_by`:** Indicates the field by which to sort.
- **`order`:** Indicates the sort order, such as ascending (`asc`) or descending (`desc`).

Example URL with sorting parameters:

```
GET /items?sort_by=name&order=asc
```

In this example:
- `sort_by=name` indicates that the results should be sorted by the `name` field.
- `order=asc` specifies that the sorting should be in ascending order.

---

### B. Handling Sorting Parameters on the Server-Side

On the server side, you need to handle these query parameters to adjust the data retrieval logic. Here's how you typically handle this in a PHP application:

1. **Retrieve Query Parameters**

   Fetch the sorting parameters from the request URL. This can be done using PHP's `$_GET` superglobal array. However, the following examples illustrates retrieving sorting params from the request object in Slim framework. 

   ```php
   $params = $request->getQueryParams();
   $sortBy = isset($params['sort_by']) ? $params['sort_by'] : 'id';
   $order = isset($params['order']) ? $params['order'] : 'asc';
   ```

2. **Validate and Sanitize Parameters**

   Always validate sorting parameters to prevent SQL injection and ensure data integrity.

   ```php
   // Define allowed fields and validate input
   $validSortByFields = ['id', 'name', 'price', 'created_at'];
   $validOrders = ['asc', 'desc'];

   // Validate sort field
   if (!in_array($sortBy, $validSortByFields)) {
       throw new InvalidArgumentException("Invalid sort field: {$sortBy}");
   }

   // Validate sort order
   if (!in_array(strtolower($order), $validOrders)) {
       throw new InvalidArgumentException("Invalid sort order: {$order}");
   }

   $order = strtoupper($order); // Ensure consistent case
   ```

3. **Build the SQL Query Safely**

   Use parameterized queries and validated field names to construct safe SQL.

   ```php
   // Use prepared statements with validated field names
   $sql = "SELECT * FROM items ORDER BY {$sortBy} {$order}";

   // For additional safety, you can map fields to actual column names
   $fieldMapping = [
       'id' => 'item_id',
       'name' => 'item_name',
       'price' => 'item_price',
       'created_at' => 'created_at'
   ];

   $actualField = $fieldMapping[$sortBy] ?? 'item_id';
   $sql = "SELECT * FROM items ORDER BY {$actualField} {$order}";
   ```

4. **Execute Query with Error Handling**

   Execute the query and handle potential errors gracefully.

   ```php
   try {
       $stmt = $pdo->prepare($sql);
       $stmt->execute();
       $items = $stmt->fetchAll(PDO::FETCH_ASSOC);

       $response = [
           'status' => 'success',
           'data' => $items,
           'sort' => [
               'field' => $sortBy,
               'order' => strtolower($order)
           ]
       ];

       header('Content-Type: application/json');
       echo json_encode($response);

   } catch (PDOException $e) {
       http_response_code(500);
       echo json_encode([
           'status' => 'error',
           'message' => 'Database error occurred'
       ]);
   }
   ```

---

## Things to Consider

### Security
- **Whitelist allowed fields:** Never allow arbitrary field names to prevent SQL injection.
- **Validate input strictly:** Check both field names and sort directions.
- **Use parameterized queries:** Even for ORDER BY clauses when possible.

### API Design
- **Document thoroughly:** Clearly specify available sort fields and expected formats.
- **Use consistent naming:** Stick to a consistent parameter naming convention (`sort`, `order_by`, etc.).
- **Provide clear errors:** Return meaningful error messages for invalid sort parameters.


### Example Error Response
```json
{
  "status": "error",
  "message": "Invalid sort parameter",
  "details": {
    "invalid_field": "unknown_field",
    "valid_fields": ["id", "name", "price", "created_at"]
  }
}
```


