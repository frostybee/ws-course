---
title: Pagination
description: Comprehensive guide to implementing pagination in RESTful web services.
topic: lectures
draft: true
sidebar:
    label: "Pagination"
    order: 3
---

import LinkOut from '../../../../components/LinkOut.astro'
import { Aside } from '@astrojs/starlight/components';

## What Is Pagination?

Pagination is the process of dividing a large set of data into smaller, more manageable chunks or **pages**. This technique is widely used in various contexts, including computing, web applications, and documents, to enhance performance, improve user experience, and manage ***large datasets*** more effectively.

In the context of RESTful web services, this approach helps to improve performance, reduce server load, and enhance the user experience by allowing client applications to retrieve data in segments rather than processing and rendering a large dataset all at once.

## Why Pagination is Important?
:::note
When dealing with large datasets, returning all the data in a single response can lead to performance issues, such as slow response times, network congestions, or excessive memory usage. Pagination allows clients to request a subset of the data, making client-server interactions more efficient.
:::

1. **Performance**: Sending a large amount of data in one response can be slow and resource-intensive. Pagination reduces the load on the server and network by breaking the data into smaller pieces.
2. **Usability**: For clients (like web browsers or mobile apps), handling smaller chunks of data is generally easier and faster. Pagination allows clients to load data incrementally, which can improve the user experience.
3. **Scalability**: By fetching data in smaller chunks, the application can handle larger datasets more efficiently, making it easier to scale.

## Common Pagination Strategies

There are several common strategies for implementing pagination in RESTful APIs:

### 1. **Offset-Based Pagination**

**Concept**:
Offset-based pagination uses a combination of an **offset** (the starting point) and a **limit** (the number of records to return) to navigate through large datasets.

**How It Works**:
- The client specifies an `offset` parameter to indicate where the next set of results should begin and a `limit` parameter to determine the number of items to return.
- For example, if a client wants the second page of results with 10 items per page, they would use `offset=10` and `limit=10`.

**Example Request**:
```
GET /items?offset=10&limit=10
```

**Pros**:
- Simple to implement and understand.
- Suitable for small to medium-sized datasets.

**Cons**:
- Performance can degrade with large offsets as the database needs to skip over rows.
- Can lead to inconsistencies if data is modified between requests (e.g., records are added or removed).

### 2. **Cursor-Based Pagination (aka Keyset Pagination)**

**Concept**:
Cursor-based pagination uses a **cursor** (usually a unique identifier or a timestamp) to indicate the position of the next set of results. This approach is often more efficient and accurate for large datasets.

**How It Works**:
- The server returns a cursor with each page of results.
- The client uses this cursor to request the next page.
- For example, if the cursor is a record ID or a timestamp, the next page request will use this cursor to fetch records starting from that point.

**Example Request**:
```
GET /items?cursor=12345&limit=10
```

**Pros**:
- More efficient for large datasets as it avoids scanning large offsets.
- Reduces the chance of missing or duplicated results when data changes.

**Cons**:
- Can be more complex to implement compared to offset-based pagination.
- Requires that each record has a unique and consistent sorting criterion.

## How Pagination Works in REST APIs

In a RESTful web service, pagination is typically implemented using query parameters to specify which subset of data should be returned. Here's how it generally works:

- **Request Parameters**: The client includes pagination parameters in the request URL. Common parameters are:
   - `page`: The page number to retrieve.
   - `limit` or `size`: The number of items per page.
   - `offset`: The number of items to skip before starting to collect the result set.

   For example, a GET request might look like this:
   ```bash
   GET /api/items?page=2&limit=10
   ```

- **Server Response**: The server responds with a subset of the data based on the requested page and limit. The response usually includes metadata to help the client understand the context of the data.

## Paginated Response Structure

A well-structured paginated REST API response is crucial for efficient data handling and user experience. It typically includes both the **data** and **metadata** about the pagination.

The following is a general JSON structure of a ***paginated*** REST API response:

```json
{
  "meta": {
    /* Metadata about the pagination */
  },
  "data": [
    /* Array of items */
  ],
  "links": {
    /* Navigation links for pagination */
  }
}
```

### 1. **Metadata**

Metadata in a paginated response typically includes information about the pagination state and other relevant details about the dataset that help client applications **navigate** and **understand** the paginated data.

 Properly handling and including this metadata are important for creating a user-friendly and efficient API experience.

:::note
This **metadata** is often included in the response body alongside the paginated data itself or as part of the **response payload**.
:::

The **`meta`** field in the response provides typically includes:

- **`total`**: The total number of items available in the dataset (not limited by the current page size), regardless of the pagination. This helps clients understand the full scope of data available.
- **`total_pages`**: The total number of pages available, calculated based on the total count and page size. This helps clients understand how many pages they might need to navigate through.
- **`current_page`**: The current page number or index of the data being returned. This helps clients keep track of which page they are viewing.
- **`page_size`**: The number of items per page, which tells clients how many items are included in each page of the response.

    ```json title="Example of an offset-based pagination metadata:"
    {
    "meta": {
        "total": 100,
        "total_pages": 10,
        "current_page": 1,
        "page_size": 10
    }
    }
  ```

### 2. **Data**

The **`data`** field contains the actual list of items returned by the REST API. This is usually an array of objects representing the resources.


```json title="Example of paginated data:"
{
  "data": [
    {
      "id": 1,
      "name": "Item 1",
      "details": "Some details about item 1"
    },
    {
      "id": 2,
      "name": "Item 2",
      "details": "Some details about item 2"
    }
  ]
}
```

### 3. **Links**

The **`links`** field contains navigation links to facilitate moving between pages. Common links include:

- **`self`**: The URI of the current page.
- **`next`**: A URI of the next page of results, if there are more pages available. This allows clients to easily fetch the subsequent set of data.
- **`prev`**: A URI of the previous page of results (if applicable). This allows clients to navigate back through the paginated data.
- **`first`**: A URI of the first page of results, providing a quick way to jump back to the beginning.
- **`last`**: A URI of the last page of results, giving clients a quick way to jump to the end of the dataset.


```json title="Example of links information in a paginated response:"
{
  "links": {
    "self": "https://api.example.com/items?page=1",
    "next": "https://api.example.com/items?page=2",
    "prev": null,
    "first": "https://api.example.com/items?page=1",
    "last": "https://api.example.com/items?page=10"
  }
}
```

### Example of a Complete Paginated Response


```json title="Combining all the elements, a complete paginated response might look like this:"
{
  "meta": {
    "total": 100,
    "total_pages": 10,
    "current_page": 1,
    "page_size": 10
  },
  "data": [
    {
      "id": 1,
      "name": "Item 1",
      "details": "Some details about item 1"
    },
    {
      "id": 2,
      "name": "Item 2",
      "details": "Some details about item 2"
    }
  ],
  "links": {
    "self": "https://api.example.com/items?page=1",
    "next": "https://api.example.com/items?page=2",
    "prev": null,
    "first": "https://api.example.com/items?page=1",
    "last": "https://api.example.com/items?page=10"
  }
}
```

## Implementing Offset-Based Pagination in MySQL

In MySQL, the `OFFSET` and `LIMIT` keywords are used to control which subset of rows is returned by a `SELECT` query. These keywords are particularly useful for pagination, where you need to include a subset of rows from a larger dataset, typically in a REST API response with multiple pages of results.

### 1. `LIMIT` Keyword

The `LIMIT` keyword is used to specify the maximum number of rows that the query should return. It can be used in **two forms**:

#### 1.1. `LIMIT number`

This form limits the result set to a specific number of rows from the beginning. For example:

```sql
SELECT * FROM items LIMIT 10;
```

This query will return the first 10 rows from the `items` table.

#### 1.2. `LIMIT offset, number`

This form allows you to specify an offset and a limit. The offset determines the starting point (i.e., the number of rows to skip), and the number specifies the number of rows to return. For example:

```sql
SELECT * FROM items LIMIT 20, 10;
```

In this query:
- `20` is the offset, so the query will skip the first 20 rows.
- `10` is the limit, so the query will return the next 10 rows, starting from row 21.

### 2. `OFFSET` Keyword

The `OFFSET` keyword is often used in conjunction with `LIMIT` to make the query more readable and flexible. It specifies the number of rows to skip before starting to return rows.

The `OFFSET` keyword can be used in the following way:

```sql
SELECT * FROM items LIMIT 10 OFFSET 20;
```

This is functionally equivalent to `LIMIT 20, 10`:

- `OFFSET 20` skips the first 20 rows.
- `LIMIT 10` returns the next 10 rows.

### Practical Example: Pagination

Pagination often combines `LIMIT` and `OFFSET` to display results in pages. For instance, if you want to display results on pages with 10 items per page, you would calculate the **offset** based on the current page number.

Assuming you are on page 3, you would calculate the offset as follows:

- Items per page: 10
- Current page: 3
- **Offset** = (Current Page - 1) * Items per Page = (3 - 1) * 10 = 20

So, you would use:

```sql
SELECT * FROM items LIMIT 10 OFFSET 20;
```

This query would return the items for the 3rd page, showing rows 21 to 30.

<Aside type="tip" title="Summary">
- **`LIMIT`**: Specifies the maximum number of rows to return.
- **`OFFSET`**: Specifies the number of rows to skip before starting to return rows.
- **`LIMIT number`**: Returns the first `number` rows.
- **`LIMIT offset, number`**: Skips `offset` rows and then returns `number` rows.
- **`LIMIT number OFFSET offset`**: Similar to `LIMIT offset, number`, specifying the number of rows to return and the offset in a more readable form.
</Aside>

## Additional Metadata in Paginated Responses

Here are some common **types of metadata** that might be included in a paginated response:

- **Links**: A collection of hyperlinks to various pages in the dataset, often using a standardized format like <LinkOut href='https://www.rfc-editor.org/info/rfc5988'>[RFC 5988]</LinkOut> (Web Linking).
-  **Sort information**: Details about how the data is sorted (e.g., by date, name, etc.), which can be useful if the sorting criteria might impact the pagination.
-  **Filter information**: Details about any filters applied to the data, which can provide context for the current paginated view.
-  **Query parameters**: Information on the query parameters used to generate the current paginated response, allowing clients to replicate or adjust the request if needed.

## **Key Considerations and Best Practices**

- **Consistency**: Ensure that the structure of your pagination response is consistent across different endpoints and versions of your API.
- **Provide metadata**: Always include metadata in responses to help clients understand the pagination state.
- **Clear documentation**: Provide clear documentation on how to use pagination parameters and what each one does.
- **Flexibility**: Support various pagination strategies, such as offset-based and cursor-based pagination, depending on your use case.
- **Performance**: For large datasets, optimize the query performance and consider caching strategies to improve response times.
- **Error handling**: Include proper error handling in your API. For instance, if a requested page exceeds the total number of pages, return a 404 or 400 status code with a clear error message.
